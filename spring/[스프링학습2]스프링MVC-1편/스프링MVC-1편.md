# 스프링 MVC1편 - 백엔드 웹 개발 핵심 기술

## 소개

백엔드 웹 개발 핵심 기술

- 여기서는 웹 애플리케이션이라는게 뭔지 이해하기 위한 학습을 진행한다
- 생짜 서블릿코드, JSP, MVC패턴도 적용해 볼 것이다. 그리고 MVC 프레임워크를 직접 만들어 볼 것이다.
- 그리고 그 위에서 스프링 MVC의 핵심 구조를 깊이 있게 파악해 볼 것이고, 그 기반을 토대로 스프링 MVC의 기본 기능들을 하나씩 학습해 볼 것이다.
- 마지막으로 실제 웹 페이지와 웹 애플리케이션을 만들어서 웹 개발을 해볼것이다.

## 웹 서버, 웹 애플리케이션 서버

- 웹 - HTTP 기반

  - 웹은 HTTP를 기반으로 통신한다
  - 모든 것이 HTTP - HTTP 메시지에 모든 것을 전송
    - HTML, TEXT
    - IMAGE, 음성, 영상, 파일
    - JSON, XML (API)
    - 거의 모든 형태의 데이터 전송 가능
    - 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

- 웹 서버

  - HTTP 기반으로 동작
  - 정적 리소스 제공, 기타 부가기능
  - 정적(파일) HTML, CSS, JS, 이미지, 영상
  - 예) NGINX, APACHE

- 웹 애플리케이션 서버 (WAS-Web Application Server)

  - HTTP 기반으로 동작
  - 웹 서버 기능 포함+ (정적 리소스 제공 가능)
  - 프로그램 코드를 실행해서 애플리케이션 로직 수행
    - 동적 HTML, HTTP API(JSON)
    - 서블릿, JSP, 스프링 MVC
  - 예) 톰캣(Tomcat), Jetty, Undertow

- 웹 서버, 웹 애플리케이션 서버(WAS)차이

  - 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직
  - 그런데 사실은 둘의 용어도 경계도 모호함
    - 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함
    - 웹 애플리케이션 서버도 웹 서버의 기능을 제공함
  - 자바는 서블릿 컨테이너 기능을 제공하면 WAS
    - 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음
  - 그냥 이렇게 정리하자
    - WAS는 애플리케이션 코드를 실행하는데 더 특화되어있다.<br>(크게는, 웹 서버는 정적 리소스(파일)를 제공하는 서버, WAS는 애플리케이션 로직을 실행하는 서버다라고 생각하자.)

## 서블릿

이번에는 서블릿에 대해서 알아보자

다음과 같이 HTML Form양식을 작성하고 전송버튼을 클릭했다고 가정해보자
<img src="./images/서블릿1.png">

그리고 웹 애플리케이션 서버를 우리가 직접 구현해야 한다고 가정해보자. 서버에서 처리해야 하는 업무는 다음과 같다
<img src="./images/서블릿2.png">

그러면 우리는 위와 같은 과정의 로직을 다 작성해야 할 것이다. 그런데 사실상 의미있는 비즈니스 로직은 username과 age를 가지고 데이터베이스에 저장 요청하는게 끝이다. 그런데 전/후 단계가 너무 많다. 모두가 다 똑같이 이것을 개발하고 있기에는 너무 효율적이지 않아서 **서블릿**이라는게 등장한다.

### 서블릿을 지원하는 WAS사용

<img src="./images/서블릿3.png">
서블릿은 위 이미지에서, 의미있는 비즈니스 로직 영역을 제외한 전/후 모든 작업을 모두 지원해준다

<br/>**서블릿**

- 특징
  ```java
  @WebServlet(name = "helloServlet", urlPatterns = "/hello")
  public class HelloServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response){
      // 애플리케이션 로직
    }
  }
  ```
  - urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행
  - HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
  - HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse.
  - 개발자는 HTTP 스펙을 매우 편리하게 사용
- HTTP 요청, 응답 흐름
  <img src="./images/서블릿4.png">
  (HTTP요청시)
  - WAS는 Request, Response객체를 새로 만들어서 서블릿 객체 호출.
  - 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용.
  - 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력.
  - WAS는 Response 객체에 담겨있는 내용으로 HTTP응답 정보를 생성
- **서블릿 컨테이너**
  <img src="./images/서블릿5.png">
  - 톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 함
  - 서블릿 컨테이너는 서블릿 객체 생성, 초기화, 호출, 종료하는 생명주기 관리
  - 서블릿 객체는 **싱글톤**으로 관리
    - 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율
      - request, response 객체는 요청이 올 때 마다 항상 객체가 새로 생성되어야 한다. 그런데 helloServlet 이라는 것은 굳이 항상 생성할 필요가 있을까? 객체를 매번 생성할 필요가 없다. (다 같이 재사용한다.)
    - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
    - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
    - **공유 변수 사용 주의**
    - 서블릿 컨테이너 종료시 함께 종료
  - JSP도 서블릿으로 변환 되어서 사용
  - 동시 요청을 위한 멀티 쓰레드 처리 지원

### 동시 요청 - 멀티 쓰레드

이번에는 동시 요청 - 멀티 쓰레드에 대해서 알아보자

클라이언트에서 서버로 요청을 하면 서버는 응답을 한다
<img src="./images/멀티쓰레드1.png">

클라이언트가 요청을 하면 TCP/IP 커넥션 연결이 되고, servlet을 호출한다
<img src="./images/멀티쓰레드2.png">

그런데 서블릿을 누가 호출하는걸까? 바로 "쓰레드"라는게 호출한다.
<img src="./images/멀티쓰레드3.png">

**쓰레드**

- 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드
- 자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행.
- 쓰레드가 없다면 자바 애플리케이션 실행이 불가능
- 쓰레드는 한번에 하나의 코드 라인만 수행
- 그래서 동시 처리가 필요하면 쓰레드를 추가로 생성해줘야 한다.

**단일 요청-쓰레드 하나 사용**

- 동시처리가 필요하기 이전에, 쓰레드 하나가 있다고 가정해보자
  <img src="./images/단일요청1.png">
- 이제 클라이언트 요청이 왔다고 가정해보자. 그러면 쓰레드가 할당된다. 그리고 이 쓰레드를 가지고 서블릿이 호출된다
  <img src="./images/단일요청2.png">
- 그리고 나서 쓰레드를 가지고 응답까지 다 되고 나면, 쓰레드는 휴식한다.
  <img src="./images/단일요청3.png">
  <img src="./images/단일요청4.png">

**다중 요청-쓰레드 하나 사용**

- 쓰레드는 하나인데 다중 요청이 들어왔다고 가정해보자.<br>먼저 요청1이 들어왔다. 그래서 쓰레드를 할당해서 요청을 처리하다가 여러 이유로 인해 처리가 지연되고 있다.
  <img src="./images/다중요청1.png">
- 그때 요청2가 들어온다. 그런데 쓰레드는 현재 하나밖에 없다. 그러면 요청2는 해당 쓰레드를 기다려야한다.
  <img src="./images/다중요청2.png">
- 결국 1번도 처리중이고, 2번도 1번이 쓰레드를 다 사용하고 줘야하는데 1번이 계속 쓰레드를 점유하고 있으니, 수행 자체를 할 수 없다.(이렇게 되면 기다리다가 나중에 둘 다 타임아웃나거나 오류가 발생할 수 있다.)
  <img src="./images/다중요청3.png">
- 이것을 해결하려면, 아주 단순하게 매 요청마다 신규 쓰레드를 생성하면 된다.(요청이 올 때 마다 무조건 쓰레드는 새로 만드는 것.)
  <img src="./images/다중요청4.png">

<br>

**요청하면 쓰레드 생성(하도록 WAS를 설계하면...!)**

- 장점
  - 동시 요청을 처리할 수 있다
  - 리소스(CPU, 메모리)가 허용할 때 까지 처리 가능
  - 하나의 쓰레드가 지연되어도, 나머지 쓰레드는 정상 동작한다.
- 단점
  - 쓰레드는 생성 비용은 매우 비싸다
    - 고객의 요청이 올 때 마다 쓰레드를 생성하면, 응답 속도가 늦어진다
  - 쓰레드는 컨텍스트 스위칭 비용이 발생한다
  - 쓰레드 생성에 제한이 없다 - 고객의 요청이 너무 많이 오면, CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.
    이것을 해결하기 위해서, 보통 WAS들은 다 아래와 같은 식으로 구현이 되어있다.(내부에 쓰레드 풀이라는 것을 사용한다.)

## 쓰레드풀

- 참고(1)
  <img src="./images/쓰레드풀-참고1.png">
  - 1번과 2번이 요청이 온다
  - 그러면 쓰레드 풀에게 놀고있는 쓰레드를 달라고 요청한다.(참고, 풀 안에 쓰레드를 미리 만들어둔다. 여기서는 200개 라고 가정)
  - 그렇게 되면 1번과 2번에게 할당했으니, 쓰레드 풀에는 198개가 된다
  - 1번과 2번 요청이 완료되면 해당 쓰레드를 죽이지 않고, 쓰레드 풀에 다시 반납한다.(그러면 다시 쓰레드 풀에는 쓰레드가 200개가 된다.)
- 참고(2)
  <img src="./images/쓰레드풀-참고2.png">
  - 이제 200개의 쓰레드가 이미 실행중이라고 가정해보자
  - 이후에 요청1과 요청2가 들어왔다. 그러면 이 요청들은 쓰레드 풀에 쓰레드가 없기 때문에, (설정에 따라)대기하거나 거절될 수 있다.(거절은 요청을 처리할 수 없으므로 요청을 뱉는다. 대기는 어느정도까지 대기를 받을지 설정할 수 있다.)

<br>

**쓰레드 풀 - 요청마다 쓰레드 생성의 단점 보안**

- 특징
  - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다
  - 쓰레드 풀에 생성가능한 쓰레드의 최대치를 관리한다.<br>톰캣은 최대 200개 기본 설정(변경가능)
- 사용
  - 쓰레드가 필요하면 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다
  - 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다
  - 최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없으면?
    - 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있다.
- 장점
  - 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답 시간이 빠르다
  - 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

**쓰레드 풀 - 실무 팁**

- WAS의 주요 튜닝 포인트는 최대 쓰레드(max thread) 수이다.
- 이 값을 너무 낮게 설정하면?
  - 동시 요청이 많으면, 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연
- 이 값을 너무 높게 설정하면?
  - 동시 요청이 많으면, CPU, 메모리 리소스 임계점 초과로 서버 다운
- 장애 발생시?
  - 클라우드면 일단 서버부터 늘리고, 이후에 튜닝
  - 클라우드가 아니면 열심히 튜닝

**쓰레드 풀 - 쓰레드 풀의 적정 숫자**

- 적정 숫자는 어떻게 찾나요?
- 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 댜름
- 성능 테스트를 꼭 해봐야 한다
  - 최대한 실제 서비스와 유사하게 성능 테스트 시도
  - 툴: 아파치 ab, 제이미터, nGrinder

**핵심은 WAS가 멀티 쓰레드를 지원한다는 것.**

- 멀티 쓰레드에 대한 부분은 WAS가 처리
- 개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됨
- 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발
- 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용(공유 변수 등)

## HTML, HTTP API, CSR, SSR

이번에는 [HTML, HTTP API, CSR, SSR]에 대해 백엔드 개발자가 숙지해야할 부분을 알아보자.

**백엔드 개발자가 HTTP를 통해서 데이터를 제공할 때 고민해야할 포인트 3가지**

- 정적 리소스를 어떻게 제공할 것인가?
- 동적으로 제공되는 HTML 페이지를 어떻게 제공할 것인가?
- HTTP API를 어떻게 제공할 것인가?

- 정적리소스
  - 고정된 HTML, CSS, JS, 이미지, 영상 등을 제공
  - 주로 웹 브라우저
    - 클라이언트에서 요청시, 웹 서버는 이미 생성된 파일을 제공한다
- HTML 페이지
  - 동적으로 필요한 HTML파일을 생성해서 전달(ex. 주문내역)
  - 웹 브라우저: HTML 해석
    - 웹 브라우저에서 동적 HTML 요청시, WAS에서 주문내역 정보 조회 후, 프로그래밍을 통해 HTML을 동적으로 생성한다. 생성된 HTML을 웹 브라우저에 내려운다.
- HTTP API
  - HTML이 아니라 데이터를 전달
  - 주로 JSON 형식 사용
  - 다양한 시스템에서 호출
  - 데이터만 주고 받음, UI화면이 필요하면, 클라이언트가 별도 처리
  - 웹, 웹 클라이언트, 서버 to 서버

HTTP API - 다양한 시스템 연동

- 주로 JSON 형태로 데이터 통신
- UI클라이언트 접점
  - 앱 클라이언트(아이폰, 안드로이드, PC 앱)
  - 웹 브라우저에서 자바스크립트를 통해 HTTP API호출
  - React, Vue.j같은 웹 클라이언트
- 서버 to 서버
  - 주문 서버 -> 결제 서버
  - 기업간 데이터 통신

**서버사이드 렌더링(SSR), 클라이언트 사이드 렌더링(CSR)**
